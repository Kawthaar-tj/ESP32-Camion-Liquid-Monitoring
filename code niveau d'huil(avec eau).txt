const int capteurPin = 34;        // Entrée analogique (ESP32)
float tension = 0.0;
float tensionFiltrée = 0.0;
float volume = 0.0;

const float alpha = 0.2;          // EMA : plus bas = plus fluide, plus haut = plus rapide

// Données de calibration : tension (V) ↔ volume (L)
const int nbPoints = 4;
float tensions[nbPoints] = {0.05, 0.23, 0.39, 0.60};
float volumes[nbPoints]  = {5.0,  10.0, 15.0, 20.0};

// Fonction d'interpolation linéaire par segments
float interpolationSegment(float tensionInput) {
  for (int i = 0; i < nbPoints - 1; i++) {
    if (tensionInput >= tensions[i] && tensionInput <= tensions[i + 1]) {
      float t1 = tensions[i];
      float t2 = tensions[i + 1];
      float v1 = volumes[i];
      float v2 = volumes[i + 1];
      float ratio = (tensionInput - t1) / (t2 - t1);
      return v1 + ratio * (v2 - v1);
    }
  }
  // Hors plage mesurée → retourne -1 ou 0 selon ce que tu préfères
  return -1.0;
}

void setup() {
  Serial.begin(115200);
}

void loop() {
  // Lecture analogique + conversion en tension
  int valeurBrute = analogRead(capteurPin);
  tension = (valeurBrute / 4095.0) * 3.3;

  // Application du filtre EMA
  tensionFiltrée = alpha * tension + (1.0 - alpha) * tensionFiltrée;

  // Interpolation volume à partir de la tension filtrée
  volume = interpolationSegment(tensionFiltrée);

  // Affichage
  Serial.print("Tension brute : ");
  Serial.print(tension, 3);
  Serial.print(" V | Tension EMA : ");
  Serial.print(tensionFiltrée, 3);
  Serial.print(" V | Volume estimé : ");
  if (volume >= 0) {
    Serial.print(volume, 2);
    Serial.println(" L");
  } else {
    Serial.println("Hors plage");
  }

  delay(500);  // Rafraîchissement toutes les 0.5s
}
